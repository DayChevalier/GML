<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_stand_down_act0</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_solid</parentName>
  <maskName>spr_stand_down_act0</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation Control

//Direction starts facing down
current_direction = 2;
//Prevents directional or resting input when active
animation_state = 0;
//Prevents action input when active
action_buffer = 0;
//Prevents all input when active
noinput_state = 0;
image_xscale = 2;
image_yscale = 2;
//sprite speed
//image_speed = 0.5

hori_press = 0;
vert_press = 0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dialogue Details

//--------Dialogue Stuff
reset_dialogue_defaults();
//Character Textbox Portrait
myPortrait          = spr_portrait_examplechar;
//Character Textbox voice clip
myVoice             = snd_voice2;
//Character Textbox font
myFont              = global.myFont;
//Character Textbox name
myName              = "Green";

myPortraitTalk      = -1;
myPortraitTalk_x    = -1;
myPortraitTalk_y    = -1;
myPortraitIdle      = -1;
myPortraitIdle_x    = -1;
myPortraitIdle_y    = -1;

myPortraitIdle_imgspd = 4/room_speed //frames per second
myPortraitTalk_imgspd = 12/room_speed //frames per second
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Directional Input
//So long as character isn't in the middle of a noinput_state action or animation
//Input can be accepted (not paused or in cutscene)
if (noinput_state ==0){



    //So long as character isn't in an animation he can move or rest
    if (animation_state = 0){

        //RESTING
        //if no direcitonal button is being pushed, change sprites back to resting
        if ((vert_press == 0) &amp;&amp; (hori_press ==0)){
            //if current direction is down...
            if current_direction == 0{
                //reset resting sprite to down facing run
                sprite_index = asset_get_index("spr_stand_up_act" +string(global.currentActor));
            //if current direction is up...
            }else if current_direction == 1{
                //reset resting sprite to up facing run
                sprite_index = asset_get_index("spr_stand_right_act" +string(global.currentActor));
            //if current direction is right...
            }else if current_direction == 2{
                //reset resting sprite to right facing run
                sprite_index = asset_get_index("spr_stand_down_act" +string(global.currentActor));
            //if current direction is left...
            }else if current_direction == 3{
                //reset resting sprite to left facing run
                sprite_index = asset_get_index("spr_stand_left_act" +string(global.currentActor));
            };
        };
        

 
        //DIRECTIONALS
        
        //Y AXIS
        //If either Y AXIS directions are being used (but not both)
        //Pressing both will net zero and act as though neither were pressed.
        vert_press = keyboard_check(global.btn_Down) + (-keyboard_check(global.btn_Up));    
        //Remove any vertical momentum that doesn't add to the current direction
        if (sign(vspeed) != vert_press) vspeed = 0;
        //Determine direction based on button press
        if (vert_press &gt; 0){
            //Mark current facing direction as Down
            current_direction = 2;
            //If no X Axis momentum is detected, change sprite to down facing
            if (hspeed==0)sprite_index = asset_get_index("spr_walk_down_act" +string(global.currentActor));
            //Correct direction for when Link started in opposite direction (Opposite directions glitch)
            if ((hspeed !=0) &amp;&amp; (sprite_index == asset_get_index("spr_walk_up_act" +string(global.currentActor)))){
                sprite_index = asset_get_index("spr_walk_down_act" +string(global.currentActor));
            };      
        };
        /** TESTING ONLY
        //Determine direction based on button press
        if (vert_press &gt; 0){
            //Mark current facing direction as Down
            current_direction = 2;
            image_xscale = 1;
            image_yscale = 1;
            image_speed = 0.5
            //If no X Axis momentum is detected, change sprite to down facing
            if (hspeed==0) sprite_index = second_male;
            //Correct direction for when Link started in opposite direction (Opposite directions glitch)
            if ((hspeed !=0) &amp;&amp; (sprite_index == asset_get_index("spr_walk_up_act" +string(global.currentActor)))){

                sprite_index = second_male;
            };      
        };        
        **/
        if (vert_press &lt; 0){
            //Mark current facing direction as Down
            current_direction = 0;
            //If no X Axis momentum is detected, change sprite to down facing
            if (hspeed==0)sprite_index = asset_get_index("spr_walk_up_act" +string(global.currentActor));
            //Correct direction for when Link started in opposite direction (Opposite directions glitch)
            if ((hspeed !=0) &amp;&amp; (sprite_index == asset_get_index("spr_walk_down_act" +string(global.currentActor)))){
                sprite_index = asset_get_index("spr_walk_up_act" +string(global.currentActor));
            };
        }; 
        
        //Otherwise begin moving in current direction
        vspeed = 2*vert_press; 
       
        //Vertical Collision
        //If Y location + veritcal speed WOULD meet with this tile
        if (place_meeting(x,y+vspeed,obj_solid))
        {
            //so long as we arent touching it, loop one incrimental pixel movement in the 
            //sign (Direction) of our movement speed till we would be touching it.
            while(!place_meeting(x,y+vert_press,obj_solid))
            {
                y += vert_press;
            }
            //Then stop all horizontal movement.
            vspeed = 0;
        }

        //If neither (or both) are pushed, no momentum.
        if (vert_press ==0){
            vspeed = 0;
        };  
        
        

        //X AXIS
        //If either X AXIS directions are being used (but not both)
        //Pressing both will net zero and act as though neither were pressed.
        hori_press = keyboard_check(global.btn_Right) + (-keyboard_check(global.btn_Left));    
        //Remove any vertical momentum that doesn't add to the current direction
        if (sign(hspeed) != hori_press) hspeed = 0;
        //Determine direction based on button press
        if (hori_press &gt; 0){
            //Mark current facing direction as RIGHT
            current_direction = 1;
            //If no Y Axis momentum is detected, change sprite to down facing
            if (vspeed==0)sprite_index = asset_get_index("spr_walk_right_act" +string(global.currentActor));
            //Correct direction for when Link started in opposite direction (Opposite directions glitch)
            if ((vspeed !=0) &amp;&amp; (sprite_index == asset_get_index("spr_walk_left_act" +string(global.currentActor)))){
                sprite_index = asset_get_index("spr_walk_right_act" +string(global.currentActor));
            };      
        };
        if (hori_press &lt; 0){
            //Mark current facing direction as Down
            current_direction = 3;
            //If no Y Axis momentum is detected, change sprite to down facing
            if (vspeed==0)sprite_index = asset_get_index("spr_walk_left_act" +string(global.currentActor));
            //Correct direction for when Link started in opposite direction (Opposite directions glitch)
            if ((vspeed !=0) &amp;&amp; (sprite_index == asset_get_index("spr_walk_right_act" +string(global.currentActor)))){
                sprite_index = asset_get_index("spr_walk_left_act" +string(global.currentActor));
            };
        }; 
        
        //Otherwise begin moving in current direction
        hspeed = 2*hori_press; 
             
        //Horizontal Collision
        //If X location + horizontal speed WOULD meet with this tile
        if (place_meeting(x+hspeed,y,obj_solid))
        {
            //so long as we arent touching it, loop one incrimental pixel movement in the 
            //sign (Direction) of our movement speed till we would be touching it.
            while(!place_meeting(x+hori_press,y,obj_solid))
            {
                x += hori_press;
            }
            //Then stop all horizontal movement.
            hspeed = 0;
        }
  
        //If neither (or both) are pushed, no momentum.
        if (hori_press ==0){
            hspeed = 0;
        };
    };
};

//If Link is in the middle of an animation_state action or animation...     
if (animation_state ==1){
    //Wait till animation reachs end
    if (image_index &gt;= image_number-1){
        //Remove animation_state flag and allow for link to return to rest
        animation_state = 0;
        action_buffer = 0;
     };
};

//Speed cannot accelerate beyond this point based on what's being held
if (speed &gt; 2) speed = 2;

//cannot leave this area
x=min(x,room_width-16);
x=max(x,16);
y=min(y,room_height-16);
y=max(y,16);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interaction Input
//So long as character isn't in the middle of a noinput_state action or animation
//Input can be accepted (not paused or in cutscene)
if (noinput_state ==0){

    //So long as character isn't in an animation he can interact
    if (animation_state = 0){

     
        //If Item Button A or B is pressed individually
        //if (global.action_press &lt;2){
            //And is not already being pressed
            if (action_buffer ==0){
                //And player is right in front of an interactable object
                if (((current_direction == 0) &amp;&amp; place_meeting(x,y-4,obj_interactable))||((current_direction == 1) &amp;&amp; place_meeting(x+4,y,obj_interactable))||((current_direction == 2) &amp;&amp; place_meeting(x,y+4,obj_interactable))||((current_direction == 3) &amp;&amp; place_meeting(x-4,y,obj_interactable))){
                    //And the A button is pressed
                    if (keyboard_check_pressed(global.btn_A)){            
                        //remove all momentum
                        hspeed=0;
                        vspeed=0; 
                        //reset animation to base
                        image_index = 0;
                        //raise an noinput flag to hold character till object lets it free.
                        animation_state =1;
                        //Activate interactable object
                        with (instance_nearest(x,y,obj_interactable)){
                            activated = 1;
                        };
                        //If up facing...
                        if (current_direction == 0){
                            //change to upward swinging animation
                            sprite_index = asset_get_index("spr_stand_up_act" +string(global.currentActor)); 
                        //If right facing...
                        } else if (current_direction == 1){
                            //change to rightward swinging animation
                            sprite_index = asset_get_index("spr_stand_right_act" +string(global.currentActor));
                        //If down facing...
                        } else if (current_direction == 2){
                            //change to downward swinging animation
                            sprite_index = asset_get_index("spr_stand_down_act" +string(global.currentActor));
                        //If left facing... 
                        } else if (current_direction == 3){
                            //change to leftward swinging animation
                            sprite_index = asset_get_index("spr_stand_left_act" +string(global.currentActor));
                        };
                    };

                };
                
            };
            
        //};
          
    };  
};
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Action Input
//So long as character isn't in the middle of a noinput_state action or animation
//Input can be accepted (not paused or in cutscene)
if (noinput_state ==0){

    //So long as character isn't in an animation he can move or rest
    if (animation_state = 0){

     
        //ITEMS BUTTONS
        //If Item Button A or B is pressed individually
        //if (global.action_press &lt;2){
            //And is not already being pressed
            if (action_buffer ==0){
            /**
                //Either slot is EMPTY and pressed...
                if (((global.tap_btn_A == 1)&amp;&amp;(global.A_slot == 0))||((global.tap_btn_B == 1)&amp;&amp;(global.B_slot == 0))){            
                    //remove all momentum
                    hspeed=0;
                    vspeed=0; 
                    //reset animation to base
                    image_index = 0;
                    //raise an animation flag to prevent moving till animation completes
                    animation_state =1;
                    //raise an action buffer to prevent other actions from being used
                    action_buffer = 1;
                    //If up facing...
                    if (current_direction == 0){
                        //change to upward swinging animation
                        sprite_index = spr_link_swing_up; 
                    //If right facing...
                    } else if (current_direction == 1){
                        //change to rightward swinging animation
                        sprite_index = spr_link_swing_right; 
                    //If down facing...
                    } else if (current_direction == 2){
                        //change to downward swinging animation
                        sprite_index = spr_link_swing_down;
                    //If left facing... 
                    } else if (current_direction == 3){
                        //change to leftward swinging animation
                        sprite_index = spr_link_swing_left;
                    };
                };
    
       **/
                //Either slot is the SWORD and is pressed...
                if (((keyboard_check_pressed(global.btn_A))&amp;&amp;(global.A_slot == 1))||(keyboard_check_pressed(global.btn_B)&amp;&amp;(global.B_slot == 1))){
                    //remove all momentum
                    hspeed=0;
                    vspeed=0;
                    //raise noinput flag to prevent moving till animation completes
                    animation_state =1;
                    //raise an action buffer to prevent other actions from being used
                    action_buffer = 1;
                    //insantiate sword object
                    sword = instance_create(x, y, obj_sword);
                    //reset animation to base
                    image_index = 0;
                    //If up facing...
                    if (current_direction == 0){
                        //change to upward swinging animation
                        sprite_index = asset_get_index("spr_swing_up_act" +string(global.currentActor)); 
                        //change sword sprite to up facing animation
                        sword.current_direction = 0;
                    //If right facing...
                    } else if (current_direction == 1){
                        //change to rightward swinging animation
                        sprite_index = asset_get_index("spr_swing_right_act" +string(global.currentActor)); 
                        //change sword sprite to right facing animation
                        sword.current_direction = 1;
                    //If down facing...
                    } else if (current_direction == 2){
                        //change to downward swinging animation
                        sprite_index = asset_get_index("spr_swing_down_act" +string(global.currentActor));
                        //change sword sprite to down facing animation
                        sword.current_direction = 2;  
                    //If left facing... 
                    } else if (current_direction == 3){
                        //change to leftward swinging animation
                        sprite_index = asset_get_index("spr_swing_left_act" +string(global.currentActor));
                        //change sword sprite to left facing animation
                        sword.current_direction = 3;
                    };
                };
       
            };
       //};
    };
};
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///No Input Stop
if (noinput_state == 1){

    hspeed = 0;
    vspeed = 0;
    //if current direction is down...
    if current_direction == 0{
        //reset resting sprite to down facing run
        sprite_index = asset_get_index("spr_stand_up_act" +string(global.currentActor));
    //if current direction is up...
    }else if current_direction == 1{
        //reset resting sprite to up facing run
        sprite_index = asset_get_index("spr_stand_right_act" +string(global.currentActor));
    //if current direction is right...
    }else if current_direction == 2{
        //reset resting sprite to right facing run
        sprite_index = asset_get_index("spr_stand_down_act" +string(global.currentActor));
    //if current direction is left...
    }else if current_direction == 3{
        //reset resting sprite to left facing run
        sprite_index = asset_get_index("spr_stand_left_act" +string(global.currentActor));
    };
};
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Dialogue box control
if(instance_exists(obj_textbox)) exit;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
